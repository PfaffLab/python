#!/usr/bin/env python
#==============================================================================
# asplice-count-hits.py
#
# Shawn Driscoll
# 20130716
#
# Gene Expression Laboratory, Pfaff
# Salk Institute for Biological Studies
#
# used to count hits to alt-splice locations identified by asplice-prepare-reference.
# expects junction hits generated by bam-to-junctions from the .junc file. 
#
# 20151211 - outputs NA's for sites with not hits to either case A or B
# 
#==============================================================================

import sys, argparse, re

# from subprocess import Popen
# from random import gauss, random, sample
# from scipy.stats import norm
# import numpy as np
# import numpy.random as npr

# R support
# import rpy2.robjects as robjects
# r = robjects.r

#==============================================================================
# main
#==============================================================================

def main(args):

	# variables

	i_hits= {}
	
	args.m = True

	# check input file
	if not file_exists(args.juncs):
		sys.stderr.write("[main] Error: input file doesn't exist (%s)\n" % args.juncs)
		return 1

	if not file_exists(args.ref):
		sys.stderr.write("[main] Error: input file doesn't exist (%s)\n" % args.ref)
		return 1

	# -- load the junctions
	sys.stderr.write("[main] loading junctions from %s\n" % args.juncs)
	fin = open(args.juncs, "r")
	for szl in fin:

		m = re.search("^track", szl)
		if m:
			continue
		m = re.search("donor\_ovl", szl)
		if m:
			continue

		ll = szl.strip().split("\t")
		
		iid = intron_to_string(ll[0:3])
		if iid in i_hits:
			sys.stderr.write("[main] Error: repeated junction in junction's file: %s\n" % iid)
			return 1
		
		# store count 
		i_hits[iid] = float(ll[3])
		
	fin.close()
	
	if args.m:
		sys.stderr.write("[main] using normal mean\n")
	
	# -- read through the asplice file and print out report of hits as we go
	sys.stderr.write("[main] counting hits at alternative splice locations\n")
	
	print "aloc_id\tgene_id\tgene_name\tstrand\ttype\ttranscripts_a\ttranscripts_b\tpositions_a\tpositions_b\thits_a\thits_b\tquant_a\tquant_b\ta_pic"
	
	fin = open(args.ref, "r")
	for szl in fin:
		ll = szl.strip().split("\t")
		
		ref_iid = ll[7].split(",")
		alt_iid = ll[8].split(",")
		
		ref_hits = []
		alt_hits = []
		
		for iid in ref_iid:
			if iid in i_hits:
				ref_hits.append(i_hits[iid])
			else:
				ref_hits.append(0)
		
		for iid in alt_iid:
			if iid in i_hits:
				alt_hits.append(i_hits[iid])
			else:
				alt_hits.append(0)
				
		ll.append(",".join(map(str, ref_hits)))
		ll.append(",".join(map(str, alt_hits)))
		
		if "cassette" in ll[4]:
			#               c
			# []----------------------------[]
			# []-----------[]---------------[]
			#       a                b
			#
			# c = alt, a+b = sum(ref)
			#
			# can use a+b and 2c
			#
			if args.m:
				ll.append(sum(ref_hits)*1.0/len(ref_hits))
				ll.append(sum(alt_hits))
			else:
				ll.append(geo_mean(ref_hits))
				ll.append(geo_mean(alt_hits))
		elif "mutually" in ll[4]:
			if args.m:
				ll.append(sum(ref_hits)*1.0/len(ref_hits))
				ll.append(sum(alt_hits)*1.0/len(alt_hits))
			else:
				ll.append(geo_mean(ref_hits))
				ll.append(geo_mean(alt_hits))			
		else:
			ll.append(sum(ref_hits))
			ll.append(sum(alt_hits))
		
		pic = 0
		depth = ll[-1]+ll[-2]
		if depth > 0:
			# calculate pic
			ll.append(ll[-2]*1.0/depth)
		else:
			# print NA
			ll.append("NA")
			
		
		print "\t".join(map(str, ll))

	fin.close()

	return 0

def intron_to_string(li):
	return "%s:%s-%s" % (li[0], li[1], li[2])

def geo_mean(x):
	n = len(x)
	root = 1./n
	
	p = 1
	for i in range(n):
		p = p*(x[i]+1)
	
	m = p**root - 1
	return m
	

def file_exists(fname):
	try:
		fin = open(fname)
	except IOError as e:
		return False

	fin.close()
	return True

#==============================================================================
# entry point
#==============================================================================


parser = argparse.ArgumentParser(description="About.")
parser.add_argument('ref', type=str, help="Alternative splice reference from asplice-prepare-reference")
parser.add_argument('juncs', type=str, help="Junctions file from bam-to-junctions (.junc)")
parser.add_argument('-m', dest="m", action="store_const", const=True, default=False, help="Use mean to quantify multiple junction counts (default: geometric mean)")
args = parser.parse_args()

if __name__ == "__main__":
	sys.exit(main(args))
